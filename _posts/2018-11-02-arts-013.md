---
layout:     post
title:      "ARTS #013 "
subtitle:   "ARTS #013"
date:       2018-11-02 20:52:00
author:     "Dan"
header-img: "img/post-bg-arst013.jpeg"
header-mask: 0.3
catalog:    true
tags:
    - ARTS
    - Algorihm
    - iOS
---


> ARTS是`由左耳朵耗子--陈皓`发起的一个活动:
每周至少做一个leetcode的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的文章。（也就是Algorithm、Review、Tip、Share简称ARTS），至少坚持一年。


## ARTS 013

这是第13篇

## Algorihm 算法题

### [479\. Largest Palindrome Product](https://leetcode.com/problems/largest-palindrome-product/description/)

Difficulty: **Easy**

Find the largest palindrome made from the product of two n-digit numbers.

Since the result could be very large, you should return the largest palindrome mod 1337.

**Example:**

Input: 2

Output: 987

Explanation: 99 x 91 = 9009, 9009 % 1337 = 987

**Note:**

The range of n is [1,8].



#### Solution

Language: **C**

这道题的标签是 **容易**，对我来说比我之前做的的**困难**的题还难，刚看到**容易**的标签之后，没怎么上心，直接用暴力搜索做，遍历所有的数字组合，求乘积，再来判断是否是回文数。结果是超时，我测试了一下当n=5的时候，就要运行几分钟。

```c
int largestPalindrome(int n) {
    if (n==1) {
        return 9;
    }
    long int left = 0;
    for (long int i = 0; i < n; i++) {
        left = left*10 + 9;
    }
    long int right = left;
    long int low = pow(10,n-1);

    int maxpalindrome = 0;

    for (; left >0; left--) {
        right=left;
        for (; right >0; right--) {
            int count = left * right;
            int count1=count;
            int palindrome = 0;
            for (; count >0; ) {
                palindrome = palindrome *10 + count%10;
                count = count/10;
            }

            if (palindrome == count1) {
                if (palindrome > maxpalindrome) {
                    maxpalindrome =palindrome;
                }
            }
        }

    }
        return maxpalindrome%1337;;
```

只能换个思路了，先找到回文数，然后进行拆分看是否符合要求，结果还是超时，我打印了一下，原来回文数挺多的，

```
int largestPalindrome(int n) {
    if (n==1) {
        return 9;
    }
    long int left = 0;
    for (long int i = 0; i < n; i++) {
        left = left*10 + 9;
    }
    long int right = left;

    long int low = pow(10,n-1);
    
    for (long int i = left * right; i>0; i--) {
        long int count = i;
        long int count1=count;
        long int palindrome = 0;
        for (; count >0; ) {
            //找回文数  1234 4321
            palindrome = palindrome *10 + count%10;
            count = count/10;
            if (count<palindrome) {
                break;
            }
            
            if (count == palindrome) {
                if (count > right) {
                    break;
                }
                for (long int j = left; j>count1/right; j--) {
                    if (count1%j ==0 ) {
                        return count1 % 1337;
                    }
                  
                }
            }
        }

    }
    return 0;
}

```

最后我自己还是没想出不超时的答案，下面的答案是别人的，拿来学习一下：

```

long int creatPalindrome(long int num,int n){
    long int p=num*pow(10,n);
    for(int i=0;i<n;i++){
        p=p+(num/(long int)pow(10,n-i-1))*(long int)pow(10,i);
        num=num%(long int)pow(10,n-i-1);
    }
    return p;
}
int largestPalindrome(int n) {
    if(n==1){return 9;}
    long int p=pow(10,n)-1;
    long int q=p;
    long int temp=pow(10,n-1);
    long int ret=0;
    long int ret1=0;
    while(p>=temp){
        ret=creatPalindrome(p,n);
        for(int i=q;i>=temp;i--){
            ret1=ret/i;
            if(ret1>=i){break;}
            if(ret1>=temp&&ret%i==0)
            {
                return ret%1337;

            }
        }
        p--;
    }
    return NULL;
}


```

## Review

1 .这篇文章来自 https://medium.freecodecamp.org/how-i-launched-an-ios-app-with-a-teenager-926b5a65a991
    这篇文章主要讲述了教一个十几岁的孩子实现一个iOS游泳相关APP内容，
2. 本周翻译了第一章的上周未翻译的部分，第一章已经翻译完成了：
  https://dandan2009.github.io/2018/10/26/Instruments-chinese-translation/


## TIPS

本周遇到一个NSCharacterSet的问题，就研究了一下这个NSCharacterSet，发现NSCharacterSet功能还是挺强大的。
### NSCharacterSet
An object representing a fixed set of Unicode character values for use in search operations.
表示用于搜索操作的一组固定Unicode字符值的对象。

#### Overview

An *NSCharacterSet* object represents a set of Unicode-compliant characters. NSString and NSScanner objects use NSCharacterSet objects to group characters together for searching operations, so that they can find any of a particular set of characters during a search. The cluster’s two public classes, NSCharacterSet and NSMutableCharacterSet, declare the programmatic interface for static and dynamic character sets, respectively.
NSCharacterSet对象表示Unicode-compliant(compliant兼容)的字符集合。NSString和NSScanner对象使用NSCharacterSet对象将字符分组以进行搜索操作，这样它们就可以在搜索过程中找到特定的一组字符。集群的两个公共类NSCharacterSet和NSMutableCharacterSet分别声明静态和动态字符集的编程接口。

The objects you create using these classes are referred to as character set objects (and when no confusion will result, merely as character sets). Because of the nature of class clusters, character set objects aren’t actual instances of the NSCharacterSet or NSMutableCharacterSet classes but of one of their private subclasses. Although a character set object’s class is private, its interface is public, as declared by these abstract superclasses, NSCharacterSet and NSMutableCharacterSet. The character set classes adopt the NSCopying and NSMutableCopying protocols, making it convenient to convert a character set of one type to the other.
使用这些类创建的对象被称为字符集对象(当不产生混淆时，仅仅作为字符集)。由于类集群的性质，字符集对象不是NSCharacterSet或NSMutableCharacterSet类的实际实例，而是它们的一个私有子类的实例。虽然字符集对象的类是私有的，但是它的接口是公共的，由这些抽象超类NSCharacterSet和NSMutableCharacterSet声明。字符集类采用了NSCopying和NSMutableCopying协议，使得将一种类型的字符集转换为另一种类型的字符集变得很方便。

The NSCharacterSet class declares the programmatic interface for an object that manages a set of Unicode characters (see the NSString class cluster specification for information on Unicode). NSCharacterSet’s principal primitive method, characterIsMember:, provides the basis for all other instance methods in its interface. A subclass of NSCharacterSet needs only to implement this method, plus mutableCopyWithZone:, for proper behavior. For optimal performance, a subclass should also override bitmapRepresentation, which otherwise works by invoking characterIsMember: for every possible Unicode value.
NSCharacterSet类声明一个对象的编程接口，该对象管理Unicode字符集合(有关Unicode的信息，请参阅NSString类集群规范)。NSCharacterSet的主基元方法characterIsMember:为它的接口中所有的实例方法提供基础。NSCharacterSet的一个子类只需要实现这个方法，加上mutableCopyWithZone:方法，就可以获得正确的行为。为了获得最佳性能，子类还应该覆盖位图表示，否则可以调用characterIsMember:对于所有可能的Unicode值。

NSCharacterSet is “toll-free bridged” with its Core Foundation counterpart, CFCharacterSetRef. See Toll-Free Bridging for more information on toll-free bridging.
NSCharacterSet是“toll-free bridged”与它的核心基础对等物CFCharacterSetRef。有关toll-free bridged的更多信息，请参阅toll-free bridged。


#### NSCharacter​Set 可以方便的对字符串进行处理

比如判断一个字符串是否以数字开头

```

NSString * string = "3dfdfsa";
unichar c = [string characterAtIndex:0];
if ([[NSCharacterSet decimalDigitCharacterSet] characterIsMember:c]) {
return YES;
} else {
return NO;
}
}

```

NSString中两个跟NSCharacterSet有关的方法：
//根据字符集来清理字符串两端的字符
- (NSString *)stringByTrimmingCharactersInSet:(NSCharacterSet *)set;
//根据字符集separator来分割字符串
- (NSArray<NSString *> *)componentsSeparatedByCharactersInSet:(NSCharacterSet *)separator;

NSString *string = @"123abc123";
        
string = [string stringByTrimmingCharactersInSet:[NSCharacterSet decimalDigitCharacterSet]];
        
NSLog(@"%@",string);//输出abc


```
//字符集的二进制数据，用于传输、归档、保存成文件
@property (readonly, copy) NSData *bitmapRepresentation;


//一个除了数字字符之外的所有字符的字符集
[[NSCharacterSet decimalDigitCharacterSet] invertedSet]


//判断aCharacter是否包含在字符集中
- (BOOL)characterIsMember:(unichar)aCharacter;
//功能貌似是一样的，入参是UTF-32的字符？？？不知道这两个方法的区别，知道的朋友不吝赐教
- (BOOL)longCharacterIsMember:(UTF32Char)theLongChar;

//判断theOtherSet是不是自身的子集
- (BOOL)isSupersetOfSet:(NSCharacterSet *)theOtherSet;


- (BOOL)hasMemberInPlane:(uint8_t)thePlane;


```





#### 对字符串进行编码：

```
NSString * string =  @"11 =Essential ,Coding Interview Questions + Coding Exercises!" ;
[string  stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet alphanumericCharacterSet]];

```

alphanumericCharacterSet 所有数字和字母（大小写不分）

编码后的结果就是：

```
11%20%3DEssential%20%2CCoding%20Interview%20Questions%20%2B%20Coding%20Exercises%21
```

可以看到上面的结果对所有数字和字母之外的所有字符都进行了编码。

然后再看下**invertedSet**的作用

```
[string stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet alphanumericCharacterSet].invertedSet]

```
加上invertedSet之后的结果如下：

```

%31%31 =%45%73%73%65%6E%74%69%61%6C ,%43%6F%64%69%6E%67 %49%6E%74%65%72%76%69%65%77 %51%75%65%73%74%69%6F%6E%73 + %43%6F%64%69%6E%67 %45%78%65%72%63%69%73%65%73!

```

可以看到只对数字和字母进行了编码。

也就是说**NSCharacterSet**可以方便的指定对什么字符进行编码。
也可以使用*characterSetWithCharactersInString*进行完全自定义编码字符

```
NSCharacterSet *dd = [NSCharacterSet characterSetWithCharactersInString@"^~_>+=\"#%/<>?@\\^`{|}"];
```



相关博客：https://nshipster.cn/nscharacterset/
#### 常用API
/**  常用快捷方法集合 （常用的，已满足大多数需求） */
 (NSCharacterSet *)controlCharacterSet; //   控制字符，包括换行符（\n）、制表符（\t）等，具体有哪些，不清楚
(NSCharacterSet *)whitespaceCharacterSet; //空格
(NSCharacterSet *)whitespaceAndNewlineCharacterSet;//空格和换行符
(NSCharacterSet *)decimalDigitCharacterSet; //0-9的数字
(NSCharacterSet *)letterCharacterSet; //所有字母
(NSCharacterSet *)lowercaseLetterCharacterSet; //小写字母
(NSCharacterSet *)uppercaseLetterCharacterSet; //大写字母
(NSCharacterSet *)nonBaseCharacterSet; //非基础
(NSCharacterSet *)alphanumericCharacterSet; //所有数字和字母（大小写不分）
(NSCharacterSet *)decomposableCharacterSet; //可分解
(NSCharacterSet *)illegalCharacterSet; //非法
(NSCharacterSet *)punctuationCharacterSet; //标点符号 指在用于分隔文字的符号
(NSCharacterSet *)capitalizedLetterCharacterSet; //大写
(NSCharacterSet *)symbolCharacterSet; //     符号字符，除了标点符号之外，例如¥、$这样的符号
(NSCharacterSet *)newlineCharacterSet NS_AVAILABLE(10_5, 2_0);//换行符



/**  根据一个给定的字符串获取一个NSCharacterSet对象 */
+ (NSCharacterSet *)characterSetWithCharactersInString:(NSString *)aString;

/** 相反字符串限制 【具体见接下的例子】 */
@property (readonly, copy) NSCharacterSet *invertedSet;

- characterIsMember:


NSCharacterSet这个类的功能有点类似于正则
：
https://nshipster.cn/nscharacterset/

NSString 与 Unicode:
https://objccn.io/issue-9-1/#peculiar-unicode-features


iOS英文博客：https://nshipster.com/
上面对应的中文版：https://nshipster.cn/

如果你对什么是字符编码搞不清楚的话（即使你有很好的专业知识），那么你应该抓住这次机会反复阅读Joel Spolsky的这篇经典的文章：https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/



## Share

1.  先分享个可以查看App Store下载量比较大或比较流行的APP用了哪些第三方库的网站：https://www.appsight.io

2. 再分享几个学习算法的网站，有的视频网站，有的是带动画的：

    * 印度小伙的算法视频  ，英语算法同时学习：https://www.youtube.com/channel/UCx-kFfzekMbhODaBss-ZnsA
    
    * 算法教程  : https://notes.diguage.com/mysql/#_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6
    
   *  图解算法： https://visualgo.net/zh
   *  
    * 这个动画可以帮你理解算法： https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
    
    * 常用算法的动画解释：https://www.toptal.com/developers/sorting-algorithms
    
    * 这个动画也不错，非常炫：http://sorting.at/

3. 再推荐个数据库课程： https://15445.courses.cs.cmu.edu/fall2017/schedule.html




